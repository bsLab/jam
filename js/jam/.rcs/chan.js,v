head	1.4;
access;
symbols;
locks
	sbosse:1.4; strict;
comment	@# @;


1.4
date	2020.02.03.09.45.01;	author sbosse;	state Exp;
branches;
next	1.3;

1.3
date	2017.05.27.18.20.36;	author sbosse;	state Exp;
branches;
next	1.2;

1.2
date	2017.05.23.07.00.43;	author sbosse;	state Exp;
branches;
next	1.1;

1.1
date	2017.05.20.15.56.53;	author sbosse;	state Exp;
branches;
next	;


desc
@@


1.4
log
@.
@
text
@/**
 **      ==============================
 **       O           O      O   OOOO
 **       O           O     O O  O   O
 **       O           O     O O  O   O
 **       OOOO   OOOO O     OOO  OOOO
 **       O   O       O    O   O O   O
 **       O   O       O    O   O O   O
 **       OOOO        OOOO O   O OOOO
 **      ==============================
 **      Dr. Stefan Bosse http://www.bsslab.de
 **
 **      COPYRIGHT: THIS SOFTWARE, EXECUTABLE AND SOURCE CODE IS OWNED
 **                 BY THE AUTHOR(S).
 **                 THIS SOURCE CODE MAY NOT BE COPIED, EXTRACTED,
 **                 MODIFIED, OR OTHERWISE USED IN A CONTEXT
 **                 OUTSIDE OF THE SOFTWARE SYSTEM.
 **
 **    $AUTHORS:     Stefan Bosse
 **    $INITIAL:     (C) 2006-2019 bLAB
 **    $CREATED:     09-02-16 by sbosse.
 **    $RCS:         $Id: chan.js,v 1.3 2017/05/27 18:20:36 sbosse Exp $
 **    $VERSION:     1.15.2
 **
 **    $INFO:
 **
 **  JavaScript AIOS Agent Node Communication Module offering P2P communication with another nodes
 **
 **  1. Virtual Link: Connecting virtual (logical) nodes using buffers
 **
 **  2. Physical Link: Connecting physical nodes (on the same physical host or remote hosts) 
 **  using AMP protocol and IP communication (including endpoint pairing across NAT routers
 **  using a rendezvous broker service)
 **    
 **  3. Physical Link: Connecting node processes (in a cluster on the same physical host) using process streams 
 **
 **   For IP-based communication ports an internal IP router is provided offering operation 
 **   of multiple ports and connections.
 **
 **   Communciation link object provided by 1.-3.:
 **
 **     type link = {
 **       on: method (@@event,@@handler) with @@event={'agent'|'signal'|'class'},
 **       send: method (@@msg) with @@msg:{agent:string|object,to:dir}|{signal:string|object},to:dir},
 **       status: method (dir) -> boolean,
 **       count: method () -> number is returning number of received (phy only) and sent bytes,
 **       connect?:method (@@to),
 **       disconnect?:method (@@to),
 **       start?:method,
 **       stop?:method
 **     } 
 **
 **
 ** Events, emitter: link+  link-  error(err="link"|string,arg?)
 **
 **
 ** TODO:
 **   - Phy capability protected communication and operations
 **
 **    $ENDOFINFO
 */
var Io = Require('com/io');
var Lz = Require('os/lz-string');
var Comp = Require('com/compat');
var Buf = Require('dos/buf');
var Net = Require('dos/network');
var Command = Net.Command;
var Status = Net.Status;
var current=none;
var Aios=none;
var CBL = Require('com/cbl');
var Amp = Require('jam/amp');
var Sec = Require('jam/security');

var options = {
  verbose:1,
  version:'1.15.2'
}
module.exports.options=options;

var SLINK = {
  INIT:'INIT',
  INITED:'INITED',
  RUNNING:'RUNNING'
}

/******************** 
 *  Virtual Circuit
 ********************
 */
 
var virtual= function (node1,node2,dir,options) {
  var self=this;
  this.node1=node1;
  this.node2=node2;
  this.dir=dir; // node1 -> node2
  this.buffer1=[];
  this.buffer2=[];
  this.count1={rcv:0,snd:0};
  this.count2={rcv:0,snd:0};
  this.compress=options.compress;

  /* NEWCOMM */
  this.handler1=[];
  this.handler2=[];
  
  // External API
  this.link1 = {
    control : function (msg,to,callback) {
      // TODO
    },
    on: function (event,callback) {
      var data;
      self.handler1[event]=callback;
      if (event=='agent' && self.buffer2.length>0) {
          // Agent receiver
          data=Comp.array.pop(self.buffer2);        
          if (self.compress) data=Lz.decompress(data);
          callback(data);
      }
    },

    send: function (msg) {
      var data;
      if (msg.agent) {
        // Agent migration
        data=msg.agent;
        if (self.compress) data=Lz.compress(data);
        if (self.handler2.agent) self.handler2.agent(self.compress?Lz.decompress(data):data);
        else self.buffer1.push(data);
        if (data.length) self.count1.snd += data.length; else self.count1.snd++;
      } else if (msg.signal) {
        // Signal propagation - signals are not queued
        data=msg.signal;
        if (data.length) self.count1.snd += data.length; else self.count1.snd++;
        if (self.handler2.signal) self.handler2.signal(data);
      }
    },
    count: function () {return self.count1.snd},
    status: function () {return true},      // Linked?
    virtual:true

  }

  this.link2 = {
    control : function (msg,to,callback) {
      // TODO
    },
    on: function (event,callback) {
      var data;
      self.handler2[event]=callback;
      if (event=='agent' && self.buffer1.length>0) {
          // Agent receiver
          data=Comp.array.pop(self.buffer1);        
          if (self.compress) data=Lz.decompress(data);
          callback(data);
      }
    },

    send: function (msg) {
      var data;
      if (msg.agent) {
        // Agent migration
        data=msg.agent;
        if (self.compress) data=Lz.compress(data);
        if (self.handler1.agent) self.handler1.agent(self.compress?Lz.decompress(data):data);
        else self.buffer2.push(data);
        if (data.length) self.count2.snd += data.length; else self.count2.snd++;
      } else if (msg.signal) {
        // Signal propagation - signals are not queued
        data=msg.signal;
        if (data.length) self.count2.snd += data.length; else self.count2.snd++;
        if (self.handler1.signal) self.handler1.signal(data);
      }
    },
    count: function () {return self.count2.snd},
    status: function () {return true},      // Linked?
    virtual:true

  }
};

virtual.prototype.init  = function () {};
virtual.prototype.start = function () {};
virtual.prototype.stop  = function () {};

var Virtual = function (node1,node2,dir,options) {
  var obj=new virtual(node1,node2,dir,options);
  return obj;
}

module.exports.Virtual=Virtual;
module.exports.current=function (module) { current=module.current; Aios=module; Amp.current(module); };




if (global.config.nonetwork) return;
/******************************* PHYSICAL *************************************/


/********************* 
 ** Physical Circuit
 *********************
 *  
 * Using UDP-AMP or process stream connections (TODO)
 * typeof options={
 *   broker?:url is UDP hole punching rendezvous broker 
 *   compress?:boolean,
 *   device?:string,
 *   name?:string is optional name of the comm. port e.g. the JAM node name,
 *   on?: { } is event handler object,
 *   oneway?:boolean,
 *   out?:function,
 *   proto?:'udp'|'tcp'|'http'|'hardware',
 *   rcv:url is this endpoint address,
 *   secure?:port string,
 *   snd?:url is remote endpoint address,
 *   stream?:boolean,
 *   verbose?
 *  }
 *  with type url = "<name>:<ipport>" | "<ip>:<ipport>" | "<ipport>"
 *  and type ipport = (1-65535) | "*"
 */
var physical= function (node,dir,options) {
  var self=this;
  options=checkOptions(options,{});
  this.options=options;
  
  this.ip=none;
  if (options.rcv) this.ip=url2addr(options.rcv);
  else this.ip={address:Amp.options.localhost,port:undefined};
  if (options.proto && this.ip) this.ip.proto=options.proto;
  
  this.node=node;
  this.dir=dir; // outgoing port (node -> dst), e.g., IP
  this.count=0;
  this.broker=options.broker;
  
  this.mode=this.options.compress?Amp.AMMode.AMO_COMPRESS:0;

  this.state = SLINK.INIT;
  this.linked = 0;
  
  this.events = [];

  this.out=Aios.log;
  
  if (this.ip.parameter && this.ip.parameter.secure) {
    this.options.secure=Sec.Port.ofString(this.ip.parameter.secure);
    delete this.ip.parameter;
    this.dir.ip=addr2url(this.ip);
  }
  
  this.amp= Amp.Amp({
      broker:options.broker?url2addr(options.broker,this.ip.address):undefined,
      dir:this.dir,
      mode:this.options.mode,
      name:this.options.name,
      node:node,
      oneway:this.options.oneway,
      multicast:this.options.multicast,
      proto:this.options.proto,  
      rcv:this.ip,
      secure:this.options.secure,
      snd:options.snd?url2addr(options.snd):undefined,
      sock:options.sock,
      verbose:options.verbose,
    });

  // External API
  this.link = {
    // Control RPC
    // STD_STATUS/PS_STUN/...
    control : function (msg,to,callback) {
      var buf,data,addr=to?url2addr(to):{};
      buf=Buf.Buffer();
      if (msg.args) Buf.buf_put_string(buf,JSON.stringify(msg.args));
      msg.tid=Comp.random.int(65536/2);
      self.callbacks[msg.tid]=callback;
      self.amp.request(msg.cmd,
                       buf, 
                       self.amp.mode & Amp.AMMode.AMO_MULTICAST? addr:undefined);        
      
    }, 
    on: function (event,callback) {
      self.events[event]=callback;
    },
    send: function (msg,to) {
      var buf,data,addr=to?url2addr(to):{};
      if (msg.agent) {
        data=msg.agent; // string of JSON+
        buf=Buf.Buffer();
        if (self.mode & Amp.AMMode.AMO_COMPRESS) data=Lz.compress(data);
        Buf.buf_put_string(buf,data); 
        // function request(cmd:integer,msg:Buffer,snd?:address)
        self.amp.request(Command.PS_MIGRATE, 
                         buf, 
                         self.amp.mode & Amp.AMMode.AMO_MULTICAST? addr:undefined);        
      } else if (msg.signal) {
        data=msg.signal;  // string of JSON
        // Signal propagation  
        buf=Buf.Buffer();
        if (self.mode & Amp.AMMode.AMO_COMPRESS) data=Lz.compress(data);
        Buf.buf_put_string(buf,data);   
        // function request(cmd:integer,msg:Buffer,snd?:address)
        self.amp.request(Command.PS_SIGNAL, 
                         buf, 
                         self.amp.mode & Amp.AMMode.AMO_MULTICAST? addr:undefined);        
      }
    },
    count: function () {return self.amp.count.rcv+self.amp.count.snd},
    status : function (to) {
      if (self.amp) {
        if (to) to=url2addr(to);
        return to?self.amp.status(to.address,to.port):self.amp.status();
      }
    },  // Linked?
    stats : function () {
      return {
        transferred:self.amp.count.rcv+self.amp.count.snd,
        linked:self.linked
      }
    },
    ip:this.ip,
    mode:this.amp.mode
  }
  
  /** Connect to remote endpoint with optional capability key protection
   *  typeof @@to = "<url>" | "<path>" | "<ip>:<ipport>" | "<ipport>"
   *  typeof @@key = string "[<port>](<rights>)[<protport>]"
   */
  this.link.connect=function (to,key) {
    // allow url2addr DNS lookup
    url2addr(to,self.ip.address,function (addr) {
      self.amp.link(addr,true,key);
    })
  };

  // Disconnect remote endpoint
  this.link.disconnect=function (to) {
    var tokens;
    if (!to){
      if (self.amp.snd && self.amp.snd.address && self.amp.snd.port)
        self.amp.unlink(self.amp.snd);
    } else {
      var addr=url2addr(to,self.ip.address);
      self.amp.unlink(addr);
    }
  };
  this.link.init=function (cb) {
    if (self.state!=SLINK.INIT) return cb?cb():null;
    self.state=SLINK.INITED;
    return self.amp.init(cb);
  }
  this.link.start=function (cb) {
    if (self.state!=SLINK.INITED) return cb?cb():null;
    self.state=SLINK.RUNNING;
    return self.amp.start(cb);
  }
  this.link.stop=function (cb) {
    if (self.state!=SLINK.RUNNING) return cb?cb():null;
    self.state=SLINK.INITED;
    return self.amp.stop(cb); 
  }
  
  if (this.broker) this.link.lookup = function (path,callback) {
    if (self.amp.lookup) self.amp.lookup(path,callback);
    else if (callback) callback([]);
  }
  // Install route notification propagation to router (if installed)
  this.amp.on('route+',function (arg,arg2) {
    if (self.router) self.router.add(arg,self.link,arg2);
    self.emit('link+',arg,arg2);
    Aios.emit('link+',arg,arg2);
    self.linked++;
  });
  this.amp.on('route-',function (arg) {
    if (self.router) self.router.delete(arg,self.link);
    self.emit('link-',arg);
    Aios.emit('link-',arg);
    self.linked--;
  });
  this.amp.on('error',function (err,arg) {
    self.emit('error',err,arg);
  });
  if (options.on) {
    for(var p in options.on) this.on(p,options.on[p]);
  }
  // Register message receiver handler
  this.amp.receiver(function (handler) {
    var code,name,env,agentid,stat,obj,buf,status;
    if (!handler) return;
    if (self.options.verbose>2) { self.out('AMP: got request:'+ Io.inspect(handler)) };
    switch (handler.cmd) {
      case Command.PS_MIGRATE:
        code = Buf.buf_get_string(handler.buf);
        // console.log(code);
        // console.log(myJam.amp.url(handler.remote))
        if (self.mode & Amp.AMMode.AMO_COMPRESS) code=Lz.decompress(code);
        if (self.events.agent) self.events.agent(code,false,handler.remote);
        break;
      case Command.PS_CREATE:
        code = Buf.buf_get_string(handler.buf);
        // console.log(code);
        // console.log(myJam.amp.url(handler.remote))
        if (self.mode & Amp.AMMode.AMO_COMPRESS) code=Lz.decompress(code);
        if (self.events.agent) self.events.agent(code,true);
        break;
      case Command.PS_WRITE:
        name = Buf.buf_get_string(handler.buf);
        code = Buf.buf_get_string(handler.buf);
        env = Buf.buf_get_string(handler.buf);
        // console.log(code);
        // console.log(myJam.amp.url(handler.remote))
        if (self.mode & Amp.AMMode.AMO_COMPRESS) code=Lz.decompress(code);
        obj={};
        try {eval("env = "+env)} catch (e) {};
        obj[name]={
          fun:code,
          env:env
        }
        if (self.events['class']) self.events['class'](obj);
        break;
      case Command.PS_SIGNAL:
        // TODO
        code = Buf.buf_get_string(handler.buf);
        // console.log(code);
        if (self.mode & Amp.AMMode.AMO_COMPRESS) code=Lz.decompress(code);
        if (self.events.signal) self.events.signal(code,handler.remote);
        break;
      case Command.PS_STUN:
        // Kill an agent (or all)
        break;
        
      // Control Mesages
      case Command.STD_STATUS:
        // Send agent and node status
        status = {}; // TODO
        buf=Buf.Buffer();
        Buf.buf_put_string(buf,JSON.stringify(status));           
        self.amp.reply(Command.STD_MONITOR,  // Hack: Reply to STD_STATUS request
                       buf, 
                       self.amp.mode & Amp.AMMode.AMO_MULTICAST? msg.remote:undefined);        
        break;
      case Command.STD_INFO:
        // Send agent-data
        status = {}; // TODO
        buf=Buf.Buffer();
        Buf.buf_put_string(buf,JSON.stringify(status));           
        self.amp.reply(Command.STD_MONITOR,  // Hack: Reply to STD_INFO request
                       buf, 
                       self.amp.mode & Amp.AMMode.AMO_MULTICAST? msg.remote:undefined);        
        break;
      case Command.STD_MONITOR:
        // Hack: Reply to STD_STATUS/INFO request
        code = JSON.parse(Buf.buf_get_string(handler.buf));
        if (self.callbacks[msg.tid]) {
          self.callbacks[msg.tid](code);
          delete self.callbacks[msg.tid];
        }
        break;
    }

  });
};

physical.prototype.emit = function (event,arg,aux1,aux2) { if (this.events[event]) this.events[event](arg,aux1,aux2)};
physical.prototype.on = function (event,handler) {this.events[event]=handler};
physical.prototype.init = function (callback) { return this.link.init(callback)};
physical.prototype.start = function (callback) {return this.link.start(callback)};
physical.prototype.stop = function () {return this.link.stop()};

var Physical = function (node,dir,options) {
  var obj=new physical(node,dir,options);
  return obj;
}

module.exports.Physical=Physical;

/*************************
** IP UTILS
*************************/
var url2addr=Amp.url2addr;
var addr2url=Amp.addr2url;
var resolve=Amp.resolve;

/*  url = "<name>:<ipport>" | "<ip>:<ipport>" | "<ipport>"
 *  and ipport = (1-65535) | "*"
function url2addr(url,defaultIP) {
  var addr={address:defaultIP||'localhost',proto:'IP',port:undefined},
      parts = url.toString().split(':');
  if (parts.length==1) {
    if (Comp.string.isNumeric(parts[0])) addr.port=Number(parts[0]); // port number
    else if (parts[0].indexOf('-') != -1) addr.port=parts[0]; // port range p0-p1
    else if (parts[0]=='*') addr.port=undefined; // any port
    else addr.address=parts[0];  // ip/url
  } else return {address:parts[0],port:parts[1]=='*'?undefined:Number(parts[1])||parts[1]};
  return addr;
};

function addr2url(addr) {
  return (addr.proto?(addr.proto+'://'):'')+addr.address+':'+(addr.port?addr.port:'*')
};
function resolve (url,defaultIP) {
  var addr=url2addr(url,defaultIP);
  return addr2url(addr) 
}
 */

function addrequal(addr1,addr2) {
  return ipequal(addr1.address,addr2.address) && addr1.port==addr2.port;
}


function ipequal(ip1,ip2) {
  if (ip1==undefined || ip2==undefined) return false;
  else if ((Comp.string.equal(ip1,'localhost') || Comp.string.equal(ip1,'127.0.0.1')) &&
           (Comp.string.equal(ip2,'localhost') || Comp.string.equal(ip2,'127.0.0.1'))) return true;
  else return ip1==ip2;
}


/***********************************************
 * IP Router using AMP/UDP/TCP/HTTP links
 * Entry point for move and send operations DIR.IP
 ***********************************************
 */

function iprouter() {
  this.routingTable={};
  this.nodeTable={};
  this.links=[];
}
// Add route and link to be used for the route (and optional remote node id)
iprouter.prototype.add = function (to,link,node) {
  to=resolve(to);
  if (options.verbose) Aios.log('[IP] iprouter: add route '+addr2url(link.ip)+' -> '+to+(node?'#'+node:''));
  this.routingTable[to]=link;
  this.nodeTable[to]=node;
}

// Add link device
iprouter.prototype.addLink = function (link) {
  if (!link.ip) link.ip='*';
  if (options.verbose) Aios.log('[IP] iprouter: add link '+addr2url(link.ip));
  this.links.push(link);
}

// Connect to a remote endpoint
iprouter.prototype.connect = function (to,key) {
  var link,p,addr;
  to=resolve(to);
  addr=url2addr(to);
  // Search for an unconnected port!?
  for(p in this.links) {
    if (this.links[p].status(to)) return;
    if (!(this.links[p].mode&Amp.AMMode.AMO_MULTICAST) && this.links[p].status()) continue;
    if (addr.proto && this.links[p].ip && this.links[p].ip.proto != addr.proto) continue;
    link=this.links[p]; 
    break;
  }
  if (link && link.connect) {
    link.connect(to,key);
  }
}

//
iprouter.prototype.count = function (dest) {
  var res=0;
  for(var i in this.links) {
    res += this.links[i].count();
  }
  return res;
}

// Remove route
iprouter.prototype.delete = function (to) {
  to=resolve(to);
  if (this.routingTable[to]) {
    if (options.verbose) Aios.log('[IP] iprouter: remove route '+addr2url(this.routingTable[to].ip)+ ' -> ' + to);
    delete this.routingTable[to];
    delete this.nodeTable[to];
  }
}

// Disconnect a remote endpoint
iprouter.prototype.disconnect = function (to) {
  // Search for a connected port!
  to=resolve(to);
  if (this.routingTable[to] && this.routingTable[to].status(to)) {
    this.routingTable[to].disconnect(to);
  }
}

/** Lookup a IP:PORT address pair of a nodeid OR contact a broker to get reachable 
 *  nodeid-IP address pairs 
 *
 */
iprouter.prototype.lookup = function (nodeid,callback) {
  var p,result=[],n=0;
  // Broker lookup with a pattern like /domain/*  (DIR.PATH)
  if (nodeid.indexOf('*')!=-1) {
    // TODO
    for (p in this.links) {
      if (this.links[p].lookup) {
        n++;
        this.links[p].lookup(nodeid,function (_result) {
          if (_result && _result.length) result=result.concat(_result);
          n--;
          if (n==0) callback(result);
        });
      }
    }
  } else for(p in this.nodeTable) { 
    if (this.nodeTable[p] == nodeid && this.routingTable[p]) return p; 
  }
} 


/** Try to find our local IP address. 
 *
 */
iprouter.prototype.ip = function () {
  for(var i in this.links) {
    if (this.links[i].ip) return this.links[i].ip;
  }
} 

/** Reverse lookup: Get the nodeid from an IP:PORT address
*   typeof @@ip = string <ip:ipport>
*/
iprouter.prototype.reverse = function (ip) {
  return this.nodeTable[ip];
}



/** Send a message
*
*/

iprouter.prototype.send = function (msg) {
  msg.to=resolve(msg.to);
  if (this.routingTable[msg.to]) {
    this.routingTable[msg.to].send(msg,msg.to);
  } else {
    
  }
}

/** Start all attached devices
*
*/
iprouter.prototype.start = function (callback) {
  var cbl=CBL(callback||function(){});
  this.links.forEach(function (link) {
    cbl.push(function (next) {link.start(next)});
  });
  cbl.start();
}

iprouter.prototype.stats = function () {
  return {
    links:Object.keys(this.routingTable).length
  }
}

// Check status of link in given direction  (or any direction dest==undefined)
// OR return all current registered routes string []  (dest=='*')!
// OR return all current connected nodes   string []  (dest=='%')!
// OR return all current registered links (ip) string [] (dest=='$')!
iprouter.prototype.status = function (dest) {
  var res,p;
  if (dest==undefined) {
    // Any registered routes?
    for(p in this.routingTable) { if (this.routingTable[p]) return true }
  } else if (dest=='*') {
    res=[];
    for(p in this.routingTable) { if (this.routingTable[p]) res.push(p) }
    return res;
  } else if (dest=='%') {
    res=[];
    for(p in this.nodeTable) { 
      if (this.nodeTable[p] && this.routingTable[p]) res.push(this.nodeTable[p]); 
    }
    return res;
  } else {
    dest=resolve(dest);
    if (this.routingTable[dest])
      return this.routingTable[dest].status(dest);
    else
      return false;
  }
  return false;
}

// Stop all attached devices
iprouter.prototype.stop = function (callback) {
  var cbl=CBL(callback||function(){});
  this.links.forEach(function (link) {
    cbl.push(function (next) {link.stop(next)});
  });
  cbl.start();
}


module.exports.iprouter=iprouter;

module.exports.Command=Command
module.exports.Status=Status

module.exports.url2addr=url2addr;
module.exports.addr2url=addr2url;
@


1.3
log
@*** empty log message ***
@
text
@d20 1
a20 1
 **    $INITIAL:     (C) 2006-2017 bLAB
d22 2
a23 2
 **    $RCS:         $Id: chan.js,v 1.2 2017/05/23 07:00:43 sbosse Exp sbosse $
 **    $VERSION:     1.3.12
d27 32
a58 3
 **  JavaScript AIOS Agent Node Communication Sub-System
 **  1. Virtual Link connecting virtual (logical) nodes using buffers
 **  2. Physical Link connecting physical nodes using UDP-AMP connection
d67 1
d71 15
d91 1
a97 2
  this.signal1=none;
  this.callback1=none;
d99 2
a100 4
  this.signal2=none;
  this.callback2=none;
  this.count1=0;
  this.count2=0;
d102 4
d107 4
a110 4
  this.link1={
    handler: function (callback) {
      // Signal receiver
      self.signal1=callback;
d112 1
a112 2
    recv: function (callback) {
      // Agent receiver
d114 6
a119 5
      self.callback1=callback;
      if (self.buffer2.length>0) {
        data=Comp.array.pop(self.buffer2);        
        if (self.compress) data=Lz.decompress(data);
        callback(data);
d122 16
a137 13
    // function send(data:string|object)
    send: function (data) {
      // Agent migration
      if (self.compress) data=Lz.compress(data);
      if (self.callback2!=none) self.callback2(self.compress?Lz.decompress(data):data);
      else self.buffer1.push(data);
      if (data.length) self.count1 += data.length; else self.count1++;
    },
    // function signal(data:string|object)
    signal: function (data) {
      // Signal propagation - signals are not queued
      if (data.length) self.count1 += data.length; else self.count1++;
      if (self.signal2) self.signal2(data);
d139 1
a139 1
    count: function () {return self.count1},
a141 1
  },
d143 5
a147 4
  this.link2={
    handler: function (callback) {
      // Signal receiver
      self.signal2=callback;
d149 1
a149 1
    recv: function (callback) {
d151 6
a156 5
      self.callback2=callback;
      if (self.buffer1.length>0) {
        data=Comp.array.pop(self.buffer1);        
        if (self.compress) data=Lz.decompress(data);
        callback(data);
d159 16
a174 13
    // function send(data:string|object)
    send: function (data) {
      // Agent migration
      if (self.compress) data=Lz.compress(data);
      if (self.callback1!=none) self.callback1(self.compress?Lz.decompress(data):data);
      else self.buffer2.push(data);
      if (data.length) self.count2 += data.length; else self.count2++;
    },
    // function send(data:string|object)
    signal: function (data) {
      // Signal propagation - signals are not queued
      if (data.length) self.count2 += data.length; else self.count2++;
      if (self.signal1) self.signal1(data);
d176 1
a176 1
    count: function () {return self.count2},
d179 1
d183 4
d192 3
a194 5
module.exports = {
  Amp:Amp,
  Virtual:Virtual,
  current:function (module) { current=module.current; Aios=module}
}
d199 2
d206 18
a223 2
 * Using UDP-AMP connection
 * type options={compress,rcv:url,snd:url,out?:function}
d227 8
a234 5
  this.options=options||{};

  if (Comp.string.isNumeric(options.rcv)) options.rcv='localhost:'+options.rcv;
  if (Comp.string.isNumeric(options.snd)) options.snd='localhost:'+options.snd;

d236 1
a236 4
  this.dst=this.options.snd;
  this.dir=dir; // node -> dst
  this.signal=none;
  this.callback=none;
d238 3
a240 1
  this.compress=this.options.compress||false;
d242 4
a245 2
  if (this.options.amp)
    this.amp= new amp(this.options);
d247 6
a252 2
  if (this.amp && this.options.out) {
    this.amp.out=this.options.out;
a253 1
  this.out=this.options.out||Io.out;
d255 56
a310 7
  this.link={
    handler: function (callback) {
      // Signal receiver
      self.signal=callback;
    },    
    recv: function (callback) {
      self.callback=callback;
d312 12
a323 6
    send: function (data) {
      var buf=Buf.Buffer();
      if (self.compress) data=Lz.compress(data);
      self.count += data.length;
      Buf.buf_put_string(buf,data);   
      if (self.amp) self.amp.request(Net.Command.PS_MIGRATE, buf,function (res) {});      
d325 25
a349 9
    signal: function (to,sig,arg) {
      // Signal propagation  
      var buf=Buf.Buffer();
      // self.count += data.length;
      // TODO
      if (self.amp) self.amp.request(Net.Command.PS_SIGNAL, buf,function (res) {}); 
    },
    count: function () {return self.count},
    status : function () { return self.amp?(self.amp.state==AMState.AMS_CONNECTED):false}  // Linked?
d351 38
a388 19
  if (this.amp) {
    this.amp.receiver(function (handler) {
      var code,agentid,stat;
      if (!handler) return;
      if (self.options.verbose>2) { self.out('AMP: got request:'+ Io.inspect(handler)) };
      switch (handler.cmd) {
        case Net.Command.PS_MIGRATE:
          code = Buf.buf_get_string(handler.buf);
          // console.log(code);
          // console.log(myJam.amp.url(handler.remote))
          if (self.compress) code=Lz.decompress(code);
          if (self.callback) self.callback(code);
          break;
        case Net.Command.PS_SIGNAL:
          // TODO
          break;
      }
    });
    this.amp.start();
d390 76
d468 6
d479 1
d481 20
d502 7
a508 2
/** Agent Manager Port (AMP) - Peer-to-Peer Link
 *  Direct JAM control using JSON object exchange
d511 11
a521 2
if (global.TARGET!= 'browser') {
  var dgram = Require('dgram');
a522 5
  var url2addr = function (str) {
      var parts = str.split(':');
      if (parts.length==1) return {address:parts[0],port:undefined};
      else return {address:parts[0],port:parts[1]};
  };
d524 5
a528 6
  var ipequal = function(ip1,ip2) {
    if (ip1==undefined || ip2==undefined) return false;
    else if ((Comp.string.equal(ip1,'localhost') || Comp.string.equal(ip1,'127.0.0.1')) &&
        (Comp.string.equal(ip2,'localhost') || Comp.string.equal(ip2,'127.0.0.1'))) return true;
    else return String.equal(ip1,ip2);
  }
d530 12
d543 6
a548 20
  var AMC_MAXLIVE=4;
    
  var AMMessageType = {
        AMMPING:1,
        AMMPONG:2,
        AMMLINK:3,
        AMMUNLINK:4,
        AMMRPCHEAD:6,
        AMMRPCDATA:7,
        print:function(op) {
            switch (op) {
                case AMMessageType.AMMPING: return "AMMPING";
                case AMMessageType.AMMPONG: return "AMMPONG";
                case AMMessageType.AMMLINK: return "AMMLINK";
                case AMMessageType.AMMUNLINK: return "AMMUNLINK";
                case AMMessageType.AMMRPCHEAD: return "AMMRPCHEAD";
                case AMMessageType.AMMRPCDATA: return "AMMRPCDATA";
                default: return "Chan.AMMessageType?";
            }
        }
d550 17
a566 1
  };
d568 8
a575 19
  var AMState = {
        AMS_NOTINIT:1,          // Not initialized conenction
        AMS_INIT:2,             // Server started, but not confirmed
        AMS_READY:3,            // Server intiialized and confirmed (other end point not connected)
        AMS_NEGOTIATE:4,            // Server intiialized, in negotiation state (other end point not connected)
        AMS_CONNECTED:5,               // Other side connected
        AMS_NOTCONNECTED:6,              // Other side not connected
        print:function(op) {
            switch (op) {
                case AMState.AMS_NOTINIT: return "AMS_NOTINIT";
                case AMState.AMS_INIT: return "AMS_INIT";
                case AMState.AMS_READY: return "AMS_READY";
                case AMState.AMS_NEGOTIATE: return "AMS_NEGOTIATE";
                case AMState.AMS_CONNECTED: return "AMS_CONNECTED";
                case AMState.AMS_NOTCONNECTED: return "AMS_NOTCONNECTED";
                default: return "Chan.AMState?";
            }
        }
    };
d577 9
d587 8
a594 8
  /** AMP UDP port
   * type url = string
   * type amp = function (options:{rcv:url,snd?:url,verbose?,out?:function,log?:number})
   */
  var amp = function (options) {
    this.options=options||{};
    this.log=options.log||0;
    if (!options.rcv) options.rcv='localhost:6000';
d596 18
a613 12
    if (Comp.string.isNumeric(options.rcv)) options.rcv='localhost:'+options.rcv;
    if (Comp.string.isNumeric(options.snd)) options.snd='localhost:'+options.snd;
    
    this.rcv_ip = url2addr(options.rcv).address;            // URL      (this side)
    this.rcv_ipport = url2addr(options.rcv).port            // IP port
    this.rcv_sock = dgram.createSocket("udp4");
    if (options.snd) {
      this.snd_ip = url2addr(options.snd).address;          // -> URL   (other side)
      this.snd_ipport = url2addr(options.snd).port;         // -> IP port
    } else {
      this.snd_ip = undefined;                              // -> URL   (other side)
      this.snd_ipport = undefined;                          // -> IP port    
d615 4
a619 3
    this.conn_port = options.conn_port||Net.uniqport();     // Connection Link Port (this side)
    this.snd_port = undefined;                              // Connection Link Port (other side)
    this.src_ipport = undefined;                            // (IP port) ->
d621 8
a628 15
    this.snd_sock = dgram.createSocket("udp4");
        
    this.dlimit = options.dlimit||512;
    
    this.url2addr = url2addr;
    
    this.out = options.out || Io.out;
    
    this.state = AMState.AMS_INIT;
    this.live=0;
    this.timer=undefined;
    this.tries=0;
    
    if (this.options.verbose>1) this.out('RCV = '+this.rcv_ip+':'+this.rcv_ipport);
  };
d630 6
a635 22
  /*
  ** Message structure
  **
  **  msgtyp            msgtyp            2
  **  =AMMRPCHEAD       =AMMRPCDATA
  **  tid               tid               2
  **  remoteport                          2
  **  cmd                                 2
  **  size                                2
  **  frags                               2
  **                    off               4
  **                    size              2
  **                    more              2
  **                    buf               *
  **  
  **  
  */
  /** Install a receiver.
   *
   */
  amp.prototype.receiver = function (callback,rcv_ip,rcv_ipport) {
    var self = this;
a636 2
    if (rcv_ip==undefined) rcv_ip=this.rcv_ip;
    if (rcv_ipport==undefined) rcv_ipport=this.rcv_ipport;
a637 152
    var cache = Comp.hashtbl.create();
    var buf = Buf.Buffer();
    var sock = this.rcv_sock;

    sock.on('listening', function () {
      var address = sock.address();
      if (self.options.verbose) self.out('[AMP] UDP receiver listening on ' + rcv_ip + ":" + rcv_ipport);
    });
    sock.on('error', function (err) {
      Io.out('[AMP] UDP error: '+err);
      server.close();
    });    
    sock.on('message', function (message, remote) {
      var handler,dfrags,dlist,msgtyp,tid,ipport,discard,off,size,thisnum,transaction,more,port;
      handler={};
      
      Buf.buf_init(buf);
      Buf.buf_of_str(buf,message);
      if (message.length >= 12) {
        msgtyp=Buf.buf_get_int16(buf);
        discard=false;
        if (self.log>0)
          self.out('[AMP] udpConnection.receive(): Receiving Message from '+remote.address + ' [' + message.length+'] '+
                   AMMessageType.print(msgtyp));
        switch (msgtyp) {

          case AMMessageType.AMMRPCHEAD:            
            tid = Buf.buf_get_int16(buf);
            port = Buf.buf_get_port(buf);
            handler.tid=tid;
            handler.remote=remote.address+':'+Buf.buf_get_int16(buf);
            handler.cmd=Buf.buf_get_int16(buf);
            handler.size=Buf.buf_get_int16(buf);
            handler.frags=Buf.buf_get_int16(buf);
            handler.buf=Buf.Buffer();
            //console.log(handler)
            if (handler.size>0) {
              dlist = Comp.array.range(0, handler.frags - 1);
              // Add transaction to cache for pending data 
              Comp.hashtbl.add(cache, handler.tid, [handler,dlist,1000]); 
            } else {
              callback(handler);
            }
            break;
            
          case AMMessageType.AMMRPCDATA:
            tid = Buf.buf_get_int16(buf);
            port = Buf.buf_get_port(buf);
            off = Buf.buf_get_int32(buf);
            size = Buf.buf_get_int16(buf);
            more = Buf.buf_get_int16(buf);
            thisnum = off/self.dlimit;
            transaction = Comp.hashtbl.find(cache,tid);
            if (transaction!=undefined) {
              handler=transaction[0];
              if (self.log>1)
                self.out('[AMP] udpConnection.receive: adding data num='+
                         thisnum+' off='+off+' size='+size+' dlist='+transaction[1]);

              Buf.buf_get_buf(buf,handler.buf,off,size);
              transaction[1]=Comp.array.filter(transaction[1],function(num) {return (num!=thisnum)});
              if (Comp.array.empty(transaction[1])) {
                  if (self.log>1) self.out('[AMP] udpConnection.receive: finalize '+remote.address + ':' + remote.port);
                  // Io.out(handler.data.toString());
                  // Deliver
                  callback(handler);
                  Comp.hashtbl.remove(cache,tid);
              }
              handler=undefined;
            }
            break;

          case AMMessageType.AMMPING:
              port = Buf.buf_get_port(buf);
              ipport = Buf.buf_get_int32(buf);
              // Send back a PONG message 
              self.pong(remote.address,ipport);
              break;

          case AMMessageType.AMMPONG:
              port = Buf.buf_get_port(buf);
              ipport = Buf.buf_get_int32(buf);
              if (self.state==AMState.AMS_CONNECTED) {
                  self.live = AMC_MAXLIVE;
              }
              break;

          case AMMessageType.AMMLINK:
              port = Buf.buf_get_port(buf);
              ipport = Buf.buf_get_int32(buf);
              if (self.snd_ip &&
                  ipequal(self.snd_ip,remote.address) &&
                  self.snd_ipport==ipport &&
                  self.state==AMState.AMS_NOTCONNECTED) 
              {
                  self.snd_port=port;
                  self.src_ipport=remote.port;
                  self.live = AMC_MAXLIVE;
                  self.link(self.snd_ip,self.snd_ipport);
                  self.state=AMState.AMS_CONNECTED;
                  self.watchdog(true);

                  if (self.options.verbose) 
                    self.out('[AMP '+Net.Print.port(self.conn_port)+'] Linked with preferred ' + remote.address + ":" + ipport+', '+
                             Net.Print.port(port));
                  
              } 
              break;
        }
      }
    });
    sock.bind(rcv_ipport, rcv_ip, function () {
      // self.snd_sock.bind(self.rcv_ipport, self.rcv_ip);
      if (self.options.verbose) self.out('[AMP] UDP receiver bound to ' + rcv_ip + ":" + rcv_ipport);
    });    
  };
  
  /**
   *
   * @@param snd_ip
   * @@param snd_ipport
   * @@param callback
   *
   * +------------+
   * AMMessageType (int16)
   * Connection Port (port)
   * Receiver IP Port (int32)
   * +------------+
   */
  amp.prototype.ping=function(snd_ip,snd_ipport,callback) {
      var self = this;
      var buf = Buf.Buffer();
      var sock = this.snd_sock;

      Buf.buf_put_int16(buf, AMMessageType.AMMPING);
      Buf.buf_put_port(buf,this.conn_port);

      if (snd_ip==undefined) snd_ip=this.snd_ip;
      if (snd_ipport==undefined) snd_ipport=this.snd_ipport;

      Buf.buf_put_int32(buf, self.rcv_ipport);

      if (this.options.verbose>1) this.out('[AMP] amp.ping: to '+snd_ip + ':' + snd_ipport);
      sock.send(buf.data,0,Buf.length(buf),snd_ipport,snd_ip,function (err) {
          if (err) {
              sock.close();
              if (callback) callback(Status.STD_IOERR);
          } else {
              if (callback) callback(Status.STD_OK);
          }
      });
  };
d639 9
a647 55
  /**
   *
   * @@param snd_ip
   * @@param snd_ipport
   * @@param callback
   * +------------+
   * AMMessageType (int16)
   * Connection Port (port)
   * Receiver IP Port (int32)
   * +------------+
   */
  amp.prototype.pong=function(snd_ip,snd_ipport,callback) {
      var self = this;
      var buf = Buf.Buffer();
      var sock = this.snd_sock;

      Buf.buf_put_int16(buf, AMMessageType.AMMPONG);
      Buf.buf_put_port(buf,this.conn_port);

      if (snd_ip==undefined) snd_ip=this.snd_ip;
      if (snd_ipport==undefined) snd_ipport=this.snd_ipport;

      Buf.buf_put_int32(buf, self.rcv_ipport);

      if (this.options.verbose>1) this.out('[AMP] amp.pong: to '+snd_ip + ':' + snd_ipport);
      sock.send(buf.data,0,Buf.length(buf),snd_ipport,snd_ip,function (err) {
          if (err) {
              sock.close();
              if (callback) callback(Status.STD_IOERR);
          } else {
              if (callback) callback(Status.STD_OK);
          }
      });
  };

  /** Send a request message to a remote node
   *
   */
  // type amp.prototype.send = function (cmd:string,msg:Buf.buffer,callback:function(res),snd_ip?,snd_ipport?)
  amp.prototype.request = function (cmd,msg,callback,snd_ip,snd_ipport) {
    var self=this;
    var buf = Buf.Buffer();
    var sock = this.snd_sock;
    var size = msg.data.length;
    var frags = div((size+self.dlimit-1),self.dlimit);
    if (snd_ip==undefined) snd_ip=this.snd_ip;
    if (snd_ipport==undefined) snd_ipport=this.snd_ipport;
    var tid = Comp.random.int(65536/2);
    Buf.buf_put_int16(buf,AMMessageType.AMMRPCHEAD);
    Buf.buf_put_int16(buf,tid);       // Transaction Message ID
    Buf.buf_put_port(buf,this.conn_port);
    Buf.buf_put_int16(buf,self.rcv_ipport);      // For reply
    Buf.buf_put_int16(buf,cmd);
    Buf.buf_put_int16(buf,size);
    Buf.buf_put_int16(buf,frags);
d649 2
a650 45
    if (self.log>1) self.out('Send AMMRPCHEAD tid='+tid+' @@'+Comp.pervasives.mtime());
    sock.send(buf.data,0,Buf.length(buf),snd_ipport,snd_ip,function (err) {
      if (self.log>1) self.out('Send AMMRPCHEAD tid='+tid+' Done with '+err+' @@'+Comp.pervasives.mtime());
      if (err) {
        sock.close();
        callback(Status.STD_IOERR,err);
      } else {
        if (size >0) {
            var dsend = function (n, off) {
                var fsize,more;
                if (frags == 1) fsize = size;
                else if (n < frags) fsize = self.dlimit;
                else fsize = size - off;
                if (n==frags) more=0; else more=1;
                Buf.buf_init(buf);
                Buf.buf_put_int16(buf, AMMessageType.AMMRPCDATA);
                Buf.buf_put_int16(buf, tid);      // Transaction Message number
                Buf.buf_put_port(buf,self.conn_port);
                Buf.buf_put_int32(buf, off);      // Data fragment offset
                Buf.buf_put_int16(buf, fsize);    // Data fragment size
                Buf.buf_put_int16(buf, more);     // More data?
                Buf.buf_put_buf(buf, msg, off, fsize);
                if (self.log>1) self.out('Send AMMRPCDATA tid='+tid+' Start #'+n+'  @@'+Comp.pervasives.mtime());
                sock.send(buf.data, 0, Buf.length(buf), snd_ipport, snd_ip, function (err) {
                    if (self.log>1) self.out('[AMP] Send AMMRPCDATA tid='+tid+' Done #'+n+' @@'+Comp.pervasives.mtime());

                    if (err) {
                      sock.close();
                      if (callback) callback(Status.STD_IOERR,err);
                    }
                    else if (n < frags) dsend(n + 1, off + fsize);
                    else {
                        if (callback) callback(Status.STD_OK,size);
                    }
                });
            };
            dsend(1,0);
        } else {
            if (callback) callback(Status.STD_OK,0);
        }
      
      }
    });
    
  };
d652 10
a661 41
  /** Negotiate a virtual communication link (peer-to-peer).
   *
   * @@param snd_ip
   * @@param snd_ipport
   * @@param callback
   *
   * +------------+
   * VCMessageType (int16)
   * Connection Port (port)
   * Receiver IP Port (int32)
   * +------------+
   *
   */
  amp.prototype.link=function(snd_ip,snd_ipport,callback) {
      var self = this;
      var buf = Buf.Buffer();
      var sock = this.snd_sock;

      if (self.state==AMState.AMS_CONNECTED) return;

      Buf.buf_put_int16(buf, AMMessageType.AMMLINK);
      Buf.buf_put_port(buf,this.conn_port);

      if (snd_ip!=undefined) this.snd_ip=snd_ip;
      if (snd_ipport!=undefined) this.snd_ipport=snd_ipport;

      if (snd_ip==undefined) snd_ip=this.snd_ip;
      if (snd_ipport==undefined) snd_ipport=this.snd_ipport;

      Buf.buf_put_int32(buf, self.rcv_ipport);

      if (this.options.verbose>1) this.out('[AMP] amp.link: to '+snd_ip + ':' + snd_ipport);
      sock.send(buf.data,0,Buf.length(buf),snd_ipport,snd_ip,function (err) {
          if (err) {
              sock.close();
              if (callback) callback(Status.STD_IOERR);
          } else {
              if (callback) callback(Status.STD_OK);
          }
      });
  };
d663 5
a667 28
  amp.prototype.unlink=function(snd_ip,snd_ipport,callback) {
      var self = this;
      var buf = Buf.Buffer();
      var sock = this.snd_sock;

      if (self.state!=AMState.AMS_CONNECTED) return;

      Buf.buf_put_int16(buf, AMMessageType.AMMUNLINK);
      Buf.buf_put_port(buf,this.conn_port);

      if (snd_ip!=undefined) this.snd_ip=snd_ip;
      if (snd_ipport!=undefined) this.snd_ipport=snd_ipport;

      if (snd_ip==undefined) snd_ip=this.snd_ip;
      if (snd_ipport==undefined) snd_ipport=this.snd_ipport;

      Buf.buf_put_int32(buf, self.rcv_ipport);

      if (this.options.verbose) this.out('[AMP] udpConnection.unlink: to '+snd_ip + ':' + snd_ipport);
      sock.send(buf.data,0,Buf.length(buf),snd_ipport,snd_ip,function (err) {
          if (err) {
              sock.close();
              if (callback) callback(Status.STD_IOERR);
          } else {
              if (callback) callback(Status.STD_OK);
          }
      });
  };
d669 25
a693 46
  /** Install a watchdog timer.
   *
   * 1. If link state is VCS_READY, retry link request.
   * 2. If link state is VCS_CONNECTED, check link end point.
   *
   * @@param run
   */
  amp.prototype.watchdog = function(run) {
      var self=this;
      if (self.timer) clearTimeout(self.timer);
      if (run) self.timer=setTimeout(function () {
          self.timer = undefined;
          switch (self.state) {
              case AMState.AMS_CONNECTED:
                  if (self.live == 0) {
                      // No PING received, disconnect...
                      if (self.options.verbose>0) 
                        self.out('[AMP '+Net.Print.port(self.conn_port)+'] Endpoint ' + self.snd_ip + ":" + self.snd_ipport +
                                             ' not responding, propably dead. Unlinking...');
                      self.state = AMState.AMS_NOTCONNECTED;
                  } else {
                      self.live--;
                      self.watchdog(true);
                      self.ping();
                  }
                  self.tries=0;
                  break;
              case AMState.AMS_NOTCONNECTED:
                  if (self.options.verbose>0 && self.tries==0) 
                    self.out('[AMP '+Net.Print.port(self.conn_port)+'] Retrying Link to ' + self.snd_ip + ":" + self.snd_ipport);
                  self.link();
                  self.tries++;
                  self.watchdog(true);
                  break;
          }
      },500);
  };

  amp.prototype.start = function() {
    this.state = AMState.AMS_NOTCONNECTED;
    this.watchdog(true);
  }
  
  var Amp = function (options) {
    var obj=new amp(options);
    return obj;
d695 2
d698 7
a704 3
} // global.TARGET=='browser'
else {
  var Amp = none;
d708 4
a711 1
module.exports.Physical=Physical;
d713 2
@


1.2
log
@*** empty log message ***
@
text
@d22 2
a23 2
 **    $RCS:         $Id: chan.js,v 1.1 2017/05/20 15:56:53 sbosse Exp $
 **    $VERSION:     1.3.10
d76 1
a76 1
    // procedure send(data:string|object)
d84 2
a85 1
    signal: function (to,sig,arg) {
d87 2
a88 1
      if (self.signal2) self.signal2(to,sig,arg);
d109 1
a109 1
    // procedure send(data:string|object)
d117 2
a118 1
    signal: function (to,sig,arg) {
d120 2
a121 1
      if (self.signal1) self.signal1(to,sig,arg);
@


1.1
log
@Initial revision
@
text
@d22 2
a23 2
 **    $RCS:         $Id: aios.js,v 1.2 2017/05/19 05:13:27 sbosse Exp $
 **    $VERSION:     1.3.9
d28 1
a28 1
 **  1. Virtual Link connecting virtual nodes using buffers
d76 1
d82 1
a82 1
      self.count1 += data.length;
d107 1
d113 1
a113 1
      self.count2 += data.length;
@
